\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}

% \algrenewcomment[1]{\(\triangleright\) #1}
\algnewcommand{\LineComment}[1]{\State \(\triangleright\) #1}

\begin{document}
\title{Designing Forward Simulator for Partially Selfing Population}
\date{\today}
\maketitle

\section{Synopsis}
\label{sec:synopsis}

This document describes design and implementation of a forward
simulation for studying heterozigosities of linked loci in a
partially-selfing population, which is modeled after hermaphrodite
species.
The simulation is implemented using
\href{http://simupop.sourceforge.net/}{simuPOP}.

\section{Design}
\label{sec:design}

A simulated population is modeled after a panmictic population of
hermaphroditic organisms with non-overlapping generations.
In the first part of this document
biological basis of the simulated population is described in detail.

\subsection{Population Structure}
\label{sec:population-structure}

The simulated population consists of hermaphroditic organisms
in a single deme, and its population size \(N\) remains constant
over generations.
After a single bout of mating, a parental generation immediately dies
down, and their offspring takes place of their parents.
A fraction \(S\) of the population are reproduced by selfing,
and the rest do so by outcrossing.
In particular outcrossers cannot reproduce by self-fertilization.

\subsection{Mating Scheme}
\label{sec:mating-scheme}

At mating stage of their life cycle,
\(S N\) selfing individuals undergo self-fertilization.
This class of organisms generate exactly \(S N\) offspring.
Each selfer in the parental generation is equilikely to leave an
offspring that will eventually reproduce in the next mating season.
Therefore, individuals can have zero, one, or more than one offspring.

The remaining \((1 - S)N\) outcrossing individuals mate with other
outcrossing individuals, and they produce exactly \((1 - S)N\) offspring.
Because they are hermaphroditic outcrossers, an individual cannot
reproduce by selfing.
At the same time, it can mate with any other oucrossers.
Therefore, an outcrosser has \((1 - S) N - 1\) potential mating
partners.
Again, individuals are equilikely to contribute offspring to the next
generation.

In total \(N\) parents leave \(N\) offspring, so population size does
not change over generations.
Within the offspring, \(S N\) organisms randomly become selfers, and
the rest are outcrossers.
Whether one organism is selfer or not is independent of under which
mode of reproduction the organism is reproduced.


\subsection{Recombination}
\label{sec:recombination}

A simulation is performed on two linked autosomal loci.
We assume that there is no intra-locus recombination in either locus,
but inter-loci recombination occurs at rate \(r\) per generation.

\subsection{Mutation}
\label{sec:mutation}

Evolution of loci is modeled under the infinite-site model of
mutations with rates \(\mu_{1}\) and \(\mu_{2}\) per generation
for the first and second loci, respectively.
Furthermore, these mutations are considered to be selectively neutral.
Mutations occurs prior to mating.  However, this condition has
very little relevance to evolution of loci.
The only place this choice affects the evolution is that organisms in
the initial generation experience mutations in addition to those in
any subsequent generations.

\section{Implementation}
\label{sec:implementation}

The simulation is implemented using
\href{http://simupop.sourceforge.net/}{simuPOP}, a forward population
genetic simulation framework available as a Python package.
This framework provides a convenient way to implement forward
simulations very quickly by providing a lot of ready-made operations
such as transmission of chromosomes with or without recombination.
Those provided operations are implemented in C++ in order to make
simulations run efficiently.

At the same time, a high level of flexibility is also provided in the
framework by allowing users to plug in additional operations written
in Python (or C++ for better run time efficiency).
For example, simuPOP does not provide an operator for hermaphroditic
mating,
but it is straight forward to implement this scheme.

From a perspective of a user, who uses siumPOP to implement forward
simulations, one concern about this package is that it
is sometimes hard to make sure that simulations are implemented as
designed.
This is due to difficulties of understanding how various operators
interact with each other under complex scenarios.

\subsection{Algorithm}
\label{sec:algorithm}

Having briefly gone over characteristics of simuPOP, simulation
algorithms for inbreeding.py is described here.
An overall structure of the simulation is given in code \ref{algo:overall}.
In words, the simulation goes by alternatively performing
mutation and reproduction for a user specified number of generations
after initializing population.
In the current simulation, initialization of population is done by
simuPOP-provided function.

Mutations under the infinite-sites model is simply implemented by
setting an allelic state of a new mutant to be the number of mutations
occurred at a locus up to that point in time.
This approach is essentially identical to implementing the
infinite-alleles model of mutations.
Unfortunately simuPOP does not provide a code for this model,
and my implementation is illustrated in code \ref{algo:mutation}.

This simplification is possible for our case because we are only
interested in heterozygosity so far.
Heterozygosity merely asks if two genes taken from a single organism
are identical in state.
Addressing this question does not require genealogical information,
which is only present in the infinite-sites model.
As a consequence, as soon as other summary statistics utilizing
genealogical information are required, this approach stops working.
Instead, more rigorous approaches are necessary for such cases.

For this simulation, simuPOP-provided operations are sufficient for
all events except mutations and selecting pairs of parents in
outcrossing reproduction.

\subsubsection{Initialization}
\label{sec:initialization}

At initialization, a population is filled with
\(N\) original organisms.
All of these organisms carry ancestral alleles at both loci.
Hence, the population is monomorphic.
Alleles are encoded by non-negative integers, and the ancestral allele
is represented by `0'.
Any mutant allele is represented by positive integers.
First \(S N\) organisms are then assigned to be selfers, and
the rest to be outcrossers.

\subsubsection{Iterations}
\label{sec:iterations}

After the population is initialized, the simulation moves forward by
alternatively applying mutation and reproduction to the population for
\(ngen\) generations.

Occurrence of mutations at the first and second locus follows
Bernoulli distribution with parameter \(\mu_{1}\) and \(\mu_{2}\).
For each individual, both genes at each locus are tested for the
presence of mutation.
When a mutation is present in an organism, an appropriate gene gets
a novel allele, whose numeric value is one more than the number of
already observed mutation events at the locus.
For example, after observing three mutation events at the first locus,
a new mutation introduces a new allele, whose numeric value is `4.'

After tests of new mutations are performed, reproduction takes place.
\(S N\) Organisms assigned to be selfers undergo self-fertilization.
This event is implemented by randomly picking an organism from
a group of all selfers to be a parent, and a single
offspring is reproduced from the parent.
This procedure is repeated until the total number of children reaches
\(S N\).

Outcrossers follow a similar reproduction scheme.
A random pair of organisms from the current generation are chosen as
parents.
Then a single offspring is reproduced from the parents.
Again, these steps are repeated until total number of children from
the outcrossers reches \((1 - S)N\) (code \ref{algo:outcrossing}).
This scheme implies that, even if a parent has multiple offspring,
another parent of its offspring are not necessarily the same
organism.
In both mating schemes, recombination occurs at a rate \(r\).

\subsubsection{termination}
\label{sec:termination}

After iterating for \(ngen\) generations, we have a final population,
the fraction of heterozygotes among the population is recorded.
Then, a run of the simulation is terminated.

\begin{algorithm}
  \caption{Overall structure}
  \label{algo:overall}
  \begin{algorithmic}
    \State Initialize \(N\) \Comment {population size}
    \State Initialize \([\mu_{1}, \mu_{2}]\) \Comment {mutation rate
      at loci 1 and 2}
    \State Initialize \(r\) \Comment {recombination rate}
    \State Initialize \(S\) \Comment {selfing rate}
    \State Initialize \(ngen\) \Comment {number of generations}
    \State Initialize \(nrep\) \Comment {number of replications}

  \item

    \ForAll {\(nrep\)}

    \LineComment {\(mut_{i}\) is a number of mutation at locus \(i\) so far}
    \State \([mut_{1}, mut_{2}] \gets [0, 0]\)

    \LineComment {initialize population}
    \State \(pop \gets\) create population of size \(N\)
    \LineComment {\(pop_{s}, pop_{o}\) are selfers and outcrossers}
    \State \(pop_{s} \gets\) select \(S N\) individuals from \(pop\) to selfers
    \State \(pop_{o} \gets\) select \((1 - S)N\) individuals from
    \(pop\) to outcrossers

    \For {\(ngen\) generations}

    \State \(pop, [mut_{1}, mut_{2}] \gets\) \Call{Add mutations}{$pop, [mut_{1}, mut_{2}]$}

  \item
    \LineComment {reproduction}
    \LineComment {\(pop'_{s}, pop'_{o}\) are offspring of selfers and outcrossers}
    \State \(pop'_{s} \gets\) selfing of \(pop_{s}\) with
    recombination rate \(r\)
    \State \(pop'_{o} \gets\) \Call{Outcrossing}{$pop_{o},
      r$}
    \LineComment {offspring generation replaces parental generation}
    \State \(pop \gets pop'_{s} \cup pop'_{o}\)
    \State \(pop_{s} \gets\) randomly select \(SN\) individuals from
    \(pop\) to selfers
    \State \(pop_{o} \gets\) randomly select \((1 - S)N\) individuals to
    outcrossers

    \EndFor

    \State Compute heterozygosity from \(pop\)

    \EndFor

  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Mutation}
  \label{algo:mutation}
  \begin{algorithmic}
    % need to use $$ for inline math to workaround a known bug in
    % ifthen package
    \Function{Add mutations}{$pop, [mut_{1}, mut_{2}]$}
    \For {\(i = 1 \to N\)}
    \For {\(j = 1 \to 2\)} \Comment {iterate over locus}
    \For {\(k = 1 \to 2\)} \Comment {iterate over chromosome}
    \If \(rng < S\)
    \State \(mut_{j} \gets mut_{j} + 1\)
    \State \(pop_{i}.locus_{j}.chromosome_{k} \gets mut_{j}\)
    \EndIf
    \EndFor
    \EndFor
    \EndFor
    \State \Return \(pop, [mut_{1}, mut_{2}]\)
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Outcrossing}
  \label{algo:outcrossing}
  \begin{algorithmic}
    \Function{Outcrossing}{$pop_o, r$}
    \State Initialize \(pop_{o}'\) as an empty list
    \For {\(i = 1 \to N\)}
    \State \(parents \gets\) pick a unique pair from \(pop_{o}\)
    \State \(child \gets\) produced from \(parents\) with
    recombination rate \(r\)
    \State Extend \(pop_{o}'\) by adding \(child\)
    \EndFor
    \State \Return \(pop_{o}'\)
    \EndFunction
  \end{algorithmic}
\end{algorithm}


\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
